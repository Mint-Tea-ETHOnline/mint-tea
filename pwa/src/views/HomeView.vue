<template>
  <main>
    <section id="mint">
      <article>
        <!-- Left Side -->
        <section id="content">
          <!-- Introduction & Connect Tab -->
          <div v-if="!account" class="form-container home">
            <div class="header-logo">
              <BlueLogo />
            </div>
            <p>
              Brew up some dynamic cross-chain NFTs with Mint Tea. Port your
              best NFTs to all the top chains and maximise your exposure.
            </p>
            <p>
              Mint dynamic Tableland NFTs with mutable metadata, all stored in
              relational data ERC721-based tables on chain, that are powered by
              smart contracts.
            </p>
            <p>
              Search and verify NFTs for rarity by name, description and image
              url across top blockchains using AI from NFT Port's API.
            </p>
            <div class="button-container">
              <button
                v-if="!account"
                @click="connectWallet"
                class="connect-button"
              >
                connect
              </button>
              <button class="explore-button">
                <router-link :to="{ name: 'explore' }">explore</router-link>
              </button>
            </div>
          </div>

          <!-- Bridge Tab -->
          <div v-if="account && formTab === 'bridge'" class="form-container">
            <h1>Bridge NFT</h1>
            <div class="input-row">
              <p>
                Bridge your top NFTs to all the best blockchains to maximise
                your exposure.
              </p>
              <p>
                Your NFT will be minted as a wrapped NFT token on the
                destination chain and locked on the chain of origin.
              </p>
            </div>

            <div v-if="waitingClaim" class="bridge-claim">
              <p v-if="claimStatusText">
                deBridge confirmations:<br />
                {{ claimStatusText }}
              </p>
              <div class="button-container">
                <button
                  class="claim-button"
                  :disabled="claimStatusText !== ''"
                  @click="claimDebridgeTx()"
                >
                  Claim NFT
                </button>
              </div>
            </div>
            <div v-if="!waitingClaim">
              <div class="select-row">
                <label class="black">Bridge From</label>

                <select
                  class="bridge-from-chain"
                  v-model="bridgeFrom"
                  :disabled="approvedBridge"
                  @change="updateBridgeFrom($event)"
                >
                  <option
                    v-for="option in bridgeFromOptions"
                    :value="option.label"
                    :key="option.key"
                  >
                    {{ option.text }}
                  </option>
                </select>
                <span class="bridge-step-one">
                  STEP 1: Select the chain you choose to bridge from
                </span>
              </div>
              <div class="select-row">
                <label class="black">Bridge To</label>
                <select
                  class="bridge-to-chain"
                  v-model="bridgeTo"
                  @change="updateBridgeTo($event)"
                >
                  <option
                    v-for="option in bridgeToOptions"
                    :value="option.label"
                    :key="option.key"
                  >
                    {{ option.text }}
                  </option>
                </select>
                <span class="bridge-step-one">
                  STEP 2: Select your token and approve the token to prepare it
                  for bridge transfer. Please ensure you keep your browser
                  window open to complete the bridging process.
                </span>
              </div>
              <div class="button-container">
                <!-- <button
                  class="bridge-button-left"
                  @click="bridgeNFT()"
                  :disabled="!approvedBridge"
                >
                  bridge
                </button> -->
                <button class="back-button" @click="switchTab('mint')">
                  back
                </button>
              </div>
            </div>
          </div>
          <!-- END Bridge Tab -->

          <!-- Mint Tab -->
          <div v-if="account && formTab === 'mint'" class="form-container">
            <h1>Mint NFT</h1>
            <div class="input-row-first">
              <label for="file">Upload file</label>
              <input
                type="file"
                name="file"
                ref="fileRef"
                placeholder="PNG, JPG, GIF, SVG or MP4"
                @change="uploadFileHandler()"
              />
            </div>
            <div class="input-row">
              <label for="name">Name *</label>
              <input
                type="text"
                name="name"
                placeholder="Enter a name"
                v-model="name"
              />
            </div>
            <div class="input-row">
              <label for="description">Description *</label>
              <textarea
                type="text"
                name="description"
                placeholder="Enter a short description..."
                v-model="description"
              />
            </div>
            <div class="input-row mb-10">
              <label for="externalUrl">External URL</label>
              <input
                type="text"
                name="externalUrl"
                placeholder="Enter an external link"
                v-model="externalUrl"
              />
            </div>
            <div class="input-row mb-10 hidden">
              <label for="animationUrl">Animation URL</label>
              <input type="text" name="animationUrl" v-model="animationUrl" />
            </div>
            <div class="input-row mb-10 hidden">
              <label for="youtubeUrl">Youtube URL</label>
              <input type="text" name="youtubeUrl" v-model="youtubeUrl" />
            </div>
            <div class="input-row-end">
              <span class="file-size">File Size {{ size ? size : 0 }}</span>
            </div>
            <div class="button-container">
              <button
                v-if="!tokenId"
                :disabled="!approvedMint || minting"
                class="mint-button"
                @click="mintNFT()"
              >
                {{ minting ? "minting" : "mint" }}
              </button>
              <button
                v-if="tokenId"
                class="mint-done-button"
                @click="CancelMint()"
              >
                done
              </button>
              <button class="bridge-button-right" @click="switchTab('bridge')">
                bridge
              </button>
            </div>
          </div>
          <!-- END Mint Tab -->
          <!-- Show loading if we uploading a file or minting, etc. -->
          <div
            v-show="loading || minting || bridging || tokenId || txHashKey"
            class="loading-message"
          >
            <div v-show="loading" class="loading">loading, please wait...</div>
            <div v-show="minting" class="loading">
              minting NFT, please wait...
            </div>
            <div
              v-if="!loading && !minting && !bridging && !txHashKey && tokenId"
              class="loading"
            >
              NFT brewed successfully...you can now add your additonal attribute
              traits
            </div>
            <div v-show="bridging" class="loading">
              bridging NFT, please wait...
            </div>
            <div v-if="txHashKey" class="mint-message">
              Your NFT has been bridged successfully! {{ txHashKey }} :
              {{ txHash }}
            </div>
          </div>
        </section>
        <!-- END Left Side -->
      </article>
      <aside>
        <!-- Right Side -->
        <section id="nft-modal" class="bubbles-brewing">
          <!-- STEP 1 : Once user uploads an asset and the file is loaded onto IPFS, we can enter a Name, Description and external URL to NFT -->
          <div
            v-if="imageUrl && !showBridgeTokens && formTab === 'mint'"
            class="nft-modal-card"
          >
            <div v-if="getUrlProtocol(imageUrl) === 'mp4'" class="nft-video">
              <video width="320" height="240" controls>
                <source :src="imageUrl" type="video/mp4" />
                Your browser does not support the video tag.
              </video>
            </div>
            <div v-if="getUrlProtocol(imageUrl) === 'mp3'" class="nft-video">
              <audio ref="player" width="320" height="240">
                <source :src="imageUrl" type="audio/mpeg" />
              </audio>
              <video width="320" height="240" controls>
                <source :src="getUrlProtocol(imageUrl)" type="video/mp4" />
                Your browser does not support the video tag.
              </video>
            </div>
            <div v-else-if="imageUrl" class="nft-modal-image">
              <img
                v-if="imageUrl"
                :src="`${getUrlProtocol(imageUrl)}`"
                :alt="`${name}`"
              />
            </div>
            <div class="nft-modal-title">
              {{ name }}
            </div>
            <div class="nft-modal-description">
              {{ description }}
            </div>
            <div class="nft-modal-external-url">
              {{ externalUrl }}
            </div>
            <!-- <div class="nft-modal-description">
              {{ animationUrl }}
            </div> -->
            <!-- <div class="nft-modal-description">
              {{ youtubeUrl }}
            </div> -->
            <div v-show="attributes" class="nft-modal-edit-attributes">
              <template v-for="attr in attributes" :key="attr.trait_id">
                <div v-if="attr.trait_value" class="nft-attribute-cards">
                  <div class="nft-attribute-card">
                    <div class="nft-attribute-card-trait">
                      #{{ attr.trait_id }} {{ attr.icon }}
                      {{ attr.display_type }} / {{ attr.trait_type }} :
                      {{ attr.trait_value }}
                      <button
                        v-show="attr.trait_id"
                        class="edit-button"
                        @click="editTrait(attr.trait_id)"
                      >
                        {{
                          showTrait.value === attr.trait_id ? "done" : "edit"
                        }}
                      </button>
                    </div>
                  </div>
                </div>
              </template>
              <template v-for="attr in attributes" :key="attr.trait_id">
                <div
                  v-if="showTrait === attr.trait_id && attr.trait_value"
                  class="nft-attribute"
                >
                  Trait #{{ attr.trait_id }}
                  <div class="nft-attribute-icon">
                    <input
                      type="text"
                      name="traitIcon"
                      v-model.lazy="attr.icon"
                      @change="updateTraitIcon(attr)"
                    />
                  </div>
                  <div class="nft-attribute-display-type">
                    <input
                      type="text"
                      name="traitDisplayType"
                      v-model.lazy="attr.display_type"
                      @change="updateTraitDisplayType(attr)"
                    />
                  </div>
                  <div class="nft-attribute-trait-type">
                    <input
                      type="text"
                      name="traitType"
                      v-model.lazy="attr.trait_type"
                      @change="updateTraitType(attr)"
                    />
                  </div>
                  <div class="nft-attribute-value">
                    <input
                      type="text"
                      name="traitValue"
                      v-model.lazy="attr.trait_value"
                      @change="updateTraitValue(attr)"
                    />
                  </div>
                </div>
              </template>
            </div>
            <!-- STEP 2 : Show Add attribute form once NFT minted -->
            <div v-show="tokenId" class="nft-modal-add-attributes">
              <div class="nft-attribute">
                <div class="nft-attribute-icon">
                  <input
                    type="text"
                    name="traitIcon"
                    placeholder="enter an icon"
                    v-model="traitIcon"
                  />
                </div>
                <div class="nft-attribute-display-type">
                  <input
                    type="text"
                    name="traitDisplayType"
                    placeholder="enter a display type, eg. boost_number"
                    v-model="traitDisplayType"
                  />
                </div>
                <div class="nft-attribute-trait-type">
                  <input
                    type="text"
                    name="traitType"
                    placeholder="enter a trait type, eg. Stamina Increase"
                    v-model="traitType"
                  />
                </div>
                <div class="nft-attribute-value">
                  <input
                    type="text"
                    name="traitValue"
                    placeholder="enter a trait value, eg. 10"
                    v-model="traitValue"
                  />
                </div>
              </div>
            </div>
            <div class="nft-modal-approve">
              <div v-show="tokenId" class="button-container">
                <button class="add-button" @click="AddNewAttribute()">
                  add new attribute
                </button>
              </div>
              <button
                v-show="!tokenId"
                :class="!approvedMint ? 'approve-button' : 'approved-button'"
                @click="ConfirmApprovedMint(true)"
              >
                {{ !approvedMint ? "approve" : "let's mint" }}
              </button>
              <div v-show="!tokenId" class="file-image-link">
                <a :href="imageUrl" title="Open in new tab" target="_blank">
                  ipfs
                </a>
              </div>
              <div v-show="tokenId" class="file-table-link">
                <!-- <a
                  :href="`https://testnet.tableland.network/query?mode=list&s=SELECT%20json_object%28%27id%27%2Ctokenid%2C%27name%27%2Cname%2C%27description%27%2Cdescription%2C%27image%27%2Cimage%2C%27external_url%27%2Cexternal_url%2C%27attributes%27%2Cjson_group_array%28json_object%28%27icon%27%2Cicon%2C%27display_type%27%2Cdisplay_type%2C%27trait_type%27%2Ctrait_type%2C%27value%27%2Cvalue%29%29%29%20FROM%20Mint_TEA_80001_2644%20JOIN%20Mint_TEA_80001_2645%20ON%20Mint_TEA_80001_2644%2Etokenid%20%3D%20Mint_TEA_80001_2645%2Emaintable_tokenid%20WHERE%20tokenid%3D${tokenId}%20group%20by%20tokenid`"
                  title="View Tableland table"
                  target="_blank"
                >
                  tableland
                </a> -->
                <a
                  :href="`https://testnet.tableland.network/query?mode=list&s=SELECT%20json_object%28%27id%27%2Ctokenid%2C%27name%27%2Cname%2C%27description%27%2Cdescription%2C%27image%27%2Cimage%2C%27external_url%27%2Cexternal_url%2C%27attributes%27%2Cjson_group_array%28json_object%28%27icon%27%2Cicon%2C%27display_type%27%2Cdisplay_type%2C%27trait_type%27%2Ctrait_type%2C%27value%27%2Cvalue%29%29%29%20FROM%20Mint_TEA_80001_2832%20JOIN%20Mint_TEA_80001_2833%20ON%20Mint_TEA_80001_2832%2Etokenid%20%3D%20Mint_TEA_80001_2833%2Emaintable_tokenid%20WHERE%20tokenid%3D${tokenId}%20group%20by%20tokenid`"
                  title="View Tableland data"
                  target="_blank"
                >
                  tableland
                </a>
              </div>
              <button
                v-show="!tokenId"
                class="cancel-button"
                @click="CancelMint()"
              >
                cancel
              </button>
              <button
                v-show="tokenId"
                class="cancel-button"
                @click="CancelMint()"
              >
                reset
              </button>
            </div>
          </div>
          <!-- Pull Tokens by Account to Bridge -->
          <div
            v-if="
              !imageUrlBridge &&
              showBridgeTokens &&
              formTab === 'bridge' &&
              !waitingClaim
            "
            class="nft-bridge-tokens"
          >
            <div v-if="bridgeFrom === 'ethereum'" class="row">
              <div class="row-header">
                <h2>Ethereum <ArrowDownBlue class="arrow-down" /></h2>
              </div>
              <div v-if="ethereumTokens.length > 0" class="row token-list">
                <template v-for="token in ethereumTokens" :key="token.contract">
                  <NftCard :token="token" @click="bridgeNFT(token)" />
                </template>
              </div>
            </div>
            <div v-if="bridgeFrom === 'polygon'" class="row">
              <div class="row-header">
                <h2>Polygon <ArrowDownBlue class="arrow-down" /></h2>
              </div>
              <div v-if="polygonTokens.length > 0" class="row token-list">
                <template v-for="token in polygonTokens" :key="token.contract">
                  <NftCard :token="token" @click="bridgeNFT(token)" />
                </template>
              </div>
            </div>
            <div v-if="bridgeFrom === 'optimism'" class="row">
              <div class="row-header">
                <h2>Optimism <ArrowDownBlue class="arrow-down" /></h2>
              </div>
              <div v-if="optimismTokens.length > 0" class="row token-list">
                <template v-for="token in optimismTokens" :key="token.contract">
                  <NftCard :token="token" @click="bridgeNFT(token)" />
                </template>
              </div>
            </div>
            <div v-if="bridgeFrom === 'arbitrum'" class="row">
              <div class="row-header">
                <h2>Arbitrum <ArrowDownBlue class="arrow-down" /></h2>
              </div>
              <div v-if="arbitrumTokens.length > 0" class="row token-list">
                <template v-for="token in arbitrumTokens" :key="token.contract">
                  <NftCard :token="token" @click="bridgeNFT(token)" />
                </template>
              </div>
            </div>
            <div v-if="bridgeFrom === 'avalanche'" class="row">
              <div class="row-header">
                <h2>Avalanche <ArrowDownBlue class="arrow-down" /></h2>
              </div>
              <div v-if="avalancheTokens.length > 0" class="row token-list">
                <template
                  v-for="token in avalancheTokens"
                  :key="token.contract"
                >
                  <NftCard :token="token" @click="bridgeNFT(token)" />
                </template>
              </div>
            </div>
          </div>
          <!-- END Pull Tokens by Account to Bridge -->
          <div
            v-if="tokenIdBridge && imageUrlBridge && formTab === 'bridge'"
            class="nft-bridge-modal-card"
          >
            <div
              v-if="getUrlProtocol(imageUrlBridge) === 'mp4'"
              class="nft-bridge-video"
            >
              <video width="320" height="240" controls>
                <source
                  :src="getUrlProtocol(imageUrlBridge)"
                  type="video/mp4"
                />
                Your browser does not support the video tag.
              </video>
            </div>
            <div
              v-if="getUrlProtocol(imageUrlBridge) === 'mp3'"
              class="nft-bridge-modal-video"
            >
              <audio ref="player" width="320" height="240">
                <source :src="imageUrlBridge" type="audio/mpeg" />
              </audio>
              <video width="320" height="240" controls>
                <source
                  :src="getUrlProtocol(imageUrlBridge)"
                  type="video/mp4"
                />
                Your browser does not support the video tag.
              </video>
            </div>
            <div v-else-if="imageUrlBridge" class="nft-bridge-modal-image">
              <img
                v-if="imageUrlBridge"
                :src="`${getUrlProtocol(imageUrlBridge)}`"
                :alt="`${nameBridge}`"
              />
            </div>
            <div class="nft-bridge-modal-title">
              {{ nameBridge }}
            </div>
            <div class="nft-bridge-modal-tokenId">
              Token Id : {{ tokenIdBridge }}
            </div>
            <div class="nft-bridge-modal-contract-address">
              Contract Address : {{ contractAddressBridge }}
            </div>
            <div class="nft-bridge-modal-approve">
              <button
                :class="!approvedBridge ? 'approve-button' : 'approved-button'"
                @click="ConfirmApprovedBridge(true)"
              >
                {{ !approvedBridge ? "approve" : "ready" }}
              </button>
              <button class="cancel-button" @click="CancelBridge()">
                cancel
              </button>
            </div>
          </div>
        </section>
      </aside>
      <!-- END Right Side -->
    </section>
    <!-- Collections -->
    <section id="collections">
      <div class="row-header">
        <h2>
          <span class="mint-black">minty</span>fresh
          <ArrowDownWhite class="arrow-down" />
        </h2>
      </div>
      <div class="row token-list">
        <template v-for="token in trendingTokens" :key="token.token_id">
          <NftCard
            v-if="token.metadata && token.metadata.image"
            :token="token"
          />
        </template>
      </div>
    </section>
    <CollectionSection />
    <AboutSection />
  </main>
</template>
<script setup>
import { ref, onMounted, onBeforeUnmount } from "vue";
/* Import Libraries */
import { ethers, BigNumber } from "ethers";
import moment from "moment";

/* Import our Pinia Store & Refs */
import { storeToRefs } from "pinia";
import { useStore } from "../store";

/* Import our IPFS and NftStorage Services */
import { uploadBlob } from "../services/ipfs.js";
import { fileSize, generateLink } from "../services/helpers";
import { nftStorage } from "../services/nftStorage.js";
import authNFT from "../services/authNFT.js";
import alchemyApi from "../services/alchemyApi.js";

/* Import our deBridge Services */
import { bridge, getTxInfo, getTxStatus, claim } from "../services/debridge.js";

/* Import SVGs */
import BlueLogo from "../assets/svgs/BlueLogo.vue?component";
import ArrowDownWhite from "../assets/svgs/ArrowDownWhite.vue?component";
import ArrowDownBlue from "../assets/svgs/ArrowDownBlue.vue?component";

/* Components */
import NftCard from "@/components/NftCard.vue";
// import ArbitrumNftCard from "@/components/ArbitrumNftCard.vue";
import CollectionSection from "@/components/CollectionSection.vue";
import AboutSection from "@/components/AboutSection.vue";

/* Mint Tea Contract Address and Contract ABI */
import contractAbi from "../../../artifacts/contracts/mint_tea_ERC721.sol/MTEA.json";
const contractAddress = "0x39FA9C170B61f8fFb00cBaFc0B6e5A794529cd48";

const stylesContract = ["color: black", "background: #e9429b"].join(";");
console.log(
  "%c🍵 Mint Tea Contract Address %s",
  stylesContract,
  contractAddress
);
const stylesAbi = ["color: black", "background: cyan"].join(";");
console.log("%c🧭 Contract ABI Source %s", stylesAbi, contractAbi.sourceName);

/* Init Pinia Store Values and Methods */
const store = useStore();
const {
  txHashKey,
  txHash,
  loading,
  minting,
  bridging,
  account,
  trendingTokens,
  ethereumTokens,
  polygonTokens,
  optimismTokens,
  arbitrumTokens,
  avalancheTokens,
} = storeToRefs(store);

/* Set Form Tab */
const formTab = ref("mint");
const showBridgeTokens = ref(false);

/* File Uploader Ref */
const fileRef = ref(null);

/* Claim Ref */
const waitingClaim = ref(false);
const claimStatusText = ref("");

/* Timer Ref */
const timer = ref(null);

/* NFT Form Metadata fields */
const tokenId = ref("");
const cid = ref("");

/* Visible on form, above hidden on form */
const name = ref("");
const description = ref("");
const imageUrl = ref(null);
const externalUrl = ref("");
const animationUrl = ref("");
const youtubeUrl = ref("");
const attributes = ref([]);

const traitTableId = ref(null);
const traitTokenId = ref(null);
const traitId = ref(null);
const traitIcon = ref("");
const traitDisplayType = ref("");
const traitType = ref("");
const traitValue = ref("");
const traitCreatedAt = ref("");
const traitUpdatedAt = ref("");

/* Traits start at 0 on mint, the date of mint is the first trait added */
const showTrait = ref(1);

/* Calculated on Mint and IPFS upload */
const size = ref("");
const createdAt = ref("");
const audioVideoType = ref("");
const approvedMint = ref(false);

/* Bridge Fields and Data */
const bridgeFrom = ref("polygon");
const bridgeFromOptions = ref([
  // { value: 1, label: "ethereum", text: "ethereum" },
  // { value: 5, label: "ethereum-testnet", text: "Ethereum Testnet" },
  { value: 137, label: "polygon", text: "polygon" },
  // { value: 80001, label: "polygon-testnet", text: "Mumbai Testnet" },
  // { value: 10, label: "optimism", text: "optimism" },
  // { value: 69, label: "optimism-testnet", text: "Optimism Testnet" },
  { value: 42161, label: "arbitrum", text: "arbitrum" },
  // { value: 421611, label: "arbitrum-testnet", text: "Arbitrum Testnet" },
  { value: 43114, label: "avalanche", text: "avalanche" },
  // { value: 421611, label: "avalanche-testnet", text: "Arbitrum Testnet" },
]);
const bridgeTo = ref("arbitrum");
const bridgeToOptions = ref([
  // { value: 1, label: "ethereum", text: "ethereum" },
  // { value: 5, label: "ethereum-testnet", text: "Ethereum Testnet" },
  { value: 137, label: "polygon", text: "polygon" },
  // { value: 80001, label: "polygon-testnet", text: "Mumbai Testnet" },
  // { value: 10, label: "optimism", text: "optimism" },
  // { value: 69, label: "optimism-testnet", text: "Optimism Testnet" },
  { value: 42161, label: "arbitrum", text: "arbitrum" },
  // { value: 421611, label: "arbitrum-testnet", text: "Arbitrum Testnet" },
  { value: 43114, label: "avalanche", text: "avalanche" },
  // { value: 421611, label: "avalanche-testnet", text: "Arbitrum Testnet" },
  // { value: 0, label: "all", text: "select all" },
]);

/* Bridge NFT Details */
const tokenIdBridge = ref("");
const contractAddressBridge = ref("");
const nameBridge = ref("");
const imageUrlBridge = ref(null);
const approvedBridge = ref(false);

/* Load our Bridge NFT to approve */
// eslint-disable-next-line no-unused-vars
function loadNFTDetails(token) {
  console.log("Bridge Token Loaded:", token);
  if (token.tokenId || token.token_id) {
    tokenIdBridge.value = token.tokenId
      ? token.tokenId
      : token.token_id
      ? token.token_id
      : "";
    console.log("Token Id:", tokenIdBridge.value);
  }
  if (token.contract) {
    contractAddressBridge.value = token.contract;
    console.log("Contract Address Bridge:", contractAddressBridge.value);
  }
  console.log("Token Metdata:", token.metadata);
  if (token.metadata.name) {
    nameBridge.value = token.metadata.name;
    console.log("Token Name Bridge:", nameBridge.value);
  }
  if (token.metadata.image) {
    imageUrlBridge.value = token.metadata.image;
    console.log("Token Image Bridge:", imageUrlBridge.value);
  }
  /* Hide the Token Panel */
  showBridgeTokens.value = false;
}

/* Fetch NFT by Account Address */
async function fetchTokens() {
  if (account.value) {
    try {
      /* Infura API */
      const authAccount = new authNFT();
      /* Ethereum */
      if (ethereumTokens.value.length === 0) {
        let ethereumTokens = await authAccount.fetchAccountNfts(
          1,
          account.value
        );
        store.addEthereumTokens(...ethereumTokens);
      }
      /* Polygon */
      if (polygonTokens.value.length === 0) {
        let polygonTokens = await authAccount.fetchAccountNfts(
          137,
          account.value
        );
        console.log(polygonTokens);
        store.addPolygonTokens(...polygonTokens);
      }

      /* We use Alchemy API for these */
      const authAlchemyAccount = new alchemyApi();
      /* Optimism */
      // if (optimismTokens.value.length === 0) {
      //   let optimismTokens = await authAlchemyAccount.fetchAccountNfts(
      //     10,
      //     account.value
      //   );
      //   store.addOptimismTokens(...optimismTokens);
      // }
      /* Arbitrum */
      if (arbitrumTokens.value.length === 0) {
        let arbitrumTokens = await authAlchemyAccount.fetchAccountNfts(
          42161,
          account.value
        );
        store.addArbitrumTokens(...arbitrumTokens);
      }
      /* Avalanche */
      // if (avalancheTokens.value.length === 0) {
      //   let avalancheTokens = await authAccount.fetchAccountNfts(
      //     42161,
      //     account.value
      //   );
      //   store.addAvalancheTokens(...avalancheTokens);
      //   let avalancheTestnetTokens = await authAccount.fetchAccountNfts(
      //     42161,
      //     account.value
      //   );
      //   store.addAvalancheTokens(...avalancheTestnetTokens);
      // }
    } catch (error) {
      console.log(`Error fetching tokens, please refresh to try again!`);
    }
  }
}

/**
 * Switch Tab
 */
const switchTab = (value) => {
  formTab.value = value;
  if (value === "mint") showBridgeTokens.value = false;
  if (value === "bridge") showBridgeTokens.value = true;
};

/**
 * Check if our Wallet is Connected to 🦊 Metamask
 */
async function checkIfWalletIsConnected() {
  try {
    /*
     * First make sure we have access to window.ethereum
     */
    const { ethereum } = window;
    if (!ethereum) {
      console.log(`Please connect 🦊 Metamask to continue!`);
      return;
    }
    /* Get our Current Account */
    const accounts = await ethereum.request({ method: "eth_accounts" });

    /* Update our Current Account in the Store */
    if (accounts.length !== 0) {
      store.updateAccount(accounts[0]);
    }
  } catch (error) {
    console.log(error);
  }
}

/**
 * Get our current 🦊 Metamask Account
 */
const getAccount = async () => {
  try {
    const { ethereum } = window;
    if (!ethereum) return;
    /* Get our Account Details */
    const accounts = await ethereum.request({ method: "eth_accounts" });
    if (accounts.length !== 0) {
      store.updateAccount(accounts[0]);

      const stylesAccounts = ["color: black", "background: cyan"].join(";");
      console.log("%c🧰 Web3 Account %s ", stylesAccounts, account.value);
    } else {
      console.log("No authorized MetaMask accounts connected!");
    }
  } catch (error) {
    console.log(error);
  }
};

/* Connect Wallet */
async function connectWallet() {
  const { ethereum } = window;
  try {
    if (!ethereum) {
      alert("Please connect 🦊 Metamask to continue!");
      return;
    }
    const [accountAddress] = await ethereum.request({
      method: "eth_requestAccounts",
    });
    console.log("Account Address", accountAddress);
    if (accountAddress) {
      store.updateAccount(accountAddress);
    }
  } catch (error) {
    console.log("Error", error);
  }
}

/* Checks what type of NFT we have image, mp3, mp4, etc. */
function getUrlProtocol(url) {
  let protocol = url.endsWith("mp4") ? 5 : 0;
  if (protocol == 0) protocol = url.endsWith("mp3") ? 6 : 0;
  if (protocol == 0) protocol = url.endsWith("gif") ? 7 : 0;
  if (protocol == 0) protocol = url.startsWith("http://") ? 1 : 0;
  if (protocol == 0) protocol = url.startsWith("https://") ? 2 : 0;
  if (protocol == 0) protocol = url.startsWith("ipfs://") ? 3 : 0;
  if (protocol == 0) protocol = url !== "" ? 4 : 0;
  switch (protocol) {
    case 1:
      return url;
    case 2:
      return url;
    case 3:
      return "https://ipfs.io/ipfs/" + url.substring(7);
    case 4:
      return generateLink(url);
    case 5:
      return "mp4";
    case 6:
      return "mp3";
    case 7:
      return url;
    case 0:
      return "Not http or https";
  }
}

/**
 * @param {File} file
 * @returns {Object}
 */
const uploadFileHandler = async () => {
  /**
   * Upload file and store using NFT.Storage
   */
  const file = fileRef.value.files;
  console.log("File :", file[0]);

  store.setLoading(true);
  const uploadResult = await uploadBlob(file[0]);

  const { error } = uploadResult;
  if (error && error instanceof Error) {
    console.log(error.message);
    store.setLoading(false);
    return uploadResult;
  }

  /* Set our NFT Metadata Form Values using IPFS best practises */
  cid.value = uploadResult.data.cid;
  /* Strip image type off our name eg, .png, .jpeg, .gif */
  // name.value = uploadResult.data.file.name.substring(
  //   0,
  //   uploadResult.data.file.name.lastIndexOf(".")
  // );
  /* Generate and IPFS URI for NFT's */
  imageUrl.value = generateLink(uploadResult.data);

  /* Set details from file upload */
  audioVideoType.value = uploadResult.data.file.type;
  size.value = fileSize(uploadResult.data.file.size);
  createdAt.value = uploadResult.data.file.created_at;
  store.setLoading(false);

  return uploadResult;
};

/**
 * Mint NFT
 */
const mintNFT = async () => {
  /**
   * Some very basic form validation
   */
  if (!name.value) {
    console.log(`Please enter a name to continue!`);
    return;
  }
  if (name.value.length < 3) {
    console.log(`Name must be longer then 3 characters!`);
    return;
  }
  if (!imageUrl.value) {
    console.log(`Please upload an image to continue!`);
    return;
  }
  if (imageUrl.value.length < 10) {
    console.log(`Please upload a valid image to continue!`);
    return;
  }
  if (!description.value) {
    console.log(`Please enter a description to continue!`);
    return;
  }
  if (description.value.length < 10) {
    console.log(`Description must be longer then 10 characters!`);
    return;
  }
  /* Show loading */
  store.setMinting(true);
  /**
   * Mint our NFT with metadata on NFT.Storage
   */
  try {
    const { ethereum } = window;
    if (ethereum) {
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(
        contractAddress,
        contractAbi.abi,
        signer
      );

      const styles = ["color: black", "background: green"].join(";");
      console.log(
        "%c🍵 Mint Tea Smart Contract Address:  %s ",
        styles,
        contractAddress
      );

      /**
       *  Receive Emitted Event from Contract
       *  @dev See NewNftMinted emitted from our smart contract safeMint function
       */
      contract.on("NewNftMinted", (receiver, timestamp, newTokenId) => {
        console.log("Receiver :", receiver);

        createdAt.value = moment.unix(timestamp).toString();
        console.log("Created At :", createdAt.value);

        tokenId.value = newTokenId.toNumber();
        console.log("TokenId :", tokenId.value);
        store.setMinting(false);
      });

      /* Store NFT Metadata on NFT.Storage */
      const nftStorageTMetadataURI = await nftStorage(
        name.value,
        description.value,
        imageUrl.value,
        externalUrl.value,
        "image/*"
      );
      const stylesNFTStorage = ["color: black", "background: #f23f3f"].join(
        ";"
      );
      console.log(
        "%c💾 NFT.Storage ipfs:// link :  %s",
        stylesNFTStorage,
        nftStorageTMetadataURI
      );
      /* Check our Transaction results */
      if (!nftStorageTMetadataURI) return;

      const mintDate = new Date();
      const mintDateTimestamp = mintDate.getTime();
      const mintDateString = mintDateTimestamp.toString();
      console.log("mintDateString", mintDateString);

      /* Mint our Tableland NFT using custom structure */
      let nftTxn = await contract.safeMint(
        signer.getAddress(),
        name.value,
        description.value,
        imageUrl.value,
        externalUrl.value ? externalUrl.value : nftStorageTMetadataURI,
        "https://cloudflare-ipfs.com/ipfs/bafkreibx3akdct6syqhkis3dqsnekukhh5ib5pdwepfki7hf45viv4ylp4",
        "date",
        "Brewed by 🍵 Mint Tea",
        mintDateString
      );

      const stylesMining = ["color: black", "background: yellow"].join(";");
      console.log("%c⛏ Mining...please wait!  %s ⛏", stylesMining, nftTxn.hash);

      // The OpenZeppelin base ERC721 contract emits a Transfer event
      // when a token is issued. tx.wait() will wait until a block containing
      // our transaction has been mined and confirmed. The transaction receipt
      // contains events emitted while processing the transaction.
      const receipt = await nftTxn.wait();

      const stylesReceipt = ["color: black", "background: #e9429b"].join(";");
      console.log(
        "%c🍵 Mint Tea just brewed a fresh one %s ",
        stylesReceipt,
        nftTxn.hash
      );

      /* Check our Transaction results */
      if (receipt.status === 1) {
        /**
         * @dev NOTE: Switch up these links once we go to Production
         * Currently set to use Polygon Mumbai Testnet
         */
        const stylesPolygon = ["color: white", "background: #7e44df"].join(";");
        console.log(
          `%c🧬 NFT Minted on Polygon, see transaction: https://mumbai.polygonscan.com/tx/${nftTxn.hash} %s`,
          stylesPolygon,
          nftTxn.hash
        );
        store.setMinting(false);
      }
      /* Stop loading */
      store.setMinting(false);
      return;
    } else {
      /* Stop loading */
      store.setMinting(false);
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    /* Stop loading */
    store.setMinting(false);
    console.log("error", error);
  }
};

/**
 * Cancel NFT Mint
 */
const CancelMint = () => {
  fileRef.value = null;
  tokenId.value = "";
  cid.value = "";
  name.value = "";
  description.value = "";
  imageUrl.value = null;
  externalUrl.value = "";
  animationUrl.value = "";
  youtubeUrl.value = "";
  attributes.value = [];

  traitTableId.value = null;
  traitTokenId.value = null;
  traitId.value = null;
  traitIcon.value = "";
  traitDisplayType.value = "";
  traitType.value = "";
  traitValue.value = "";
  traitCreatedAt.value = "";
  traitUpdatedAt.value = "";
  tokenIdBridge.value = "";
  contractAddressBridge.value = "";
  nameBridge.value = "";
  imageUrlBridge.value = null;
  approvedBridge.value = false;
  showBridgeTokens.value = true;
  /* Stop All Loaders */
  store.setLoading(false);
  store.setMinting(false);
  store.setBridging(false);
};

/**
 * Approve Tableland NFT Mint
 */
const ConfirmApprovedMint = (value) => {
  approvedMint.value = value;
};

/**
 * Add a new attribute to a Tableland NFT
 */
const AddNewAttribute = async () => {
  if (!tokenId.value) {
    console.log(`Error, no NFT token id received!`);
    return;
  }
  if (!traitIcon.value) {
    console.log(`Please enter a trait icon to continue!`);
    return;
  }
  if (!traitDisplayType.value) {
    console.log(`Please enter a trait display type to continue!`);
    return;
  }
  if (!traitType.value) {
    console.log(`Please enter a trait type to continue!`);
    return;
  }
  if (!traitValue.value) {
    console.log(`Please enter a value for the trait to continue!`);
    return;
  }
  store.setMinting(false);
  /* Start loading */
  store.setLoading(true);
  try {
    const { ethereum } = window;
    if (ethereum) {
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(
        contractAddress,
        contractAbi.abi,
        signer
      );

      /**
       *  Receive Emitted Event from Smart Contract
       *  @dev See newAttributeAdded emitted from our smart contract add_new_attribute function
       */
      contract.on(
        "newAttributeAdded",
        (receiver, timestamp, token_id, trait_id) => {
          console.log("Receiver :", receiver);

          traitCreatedAt.value = moment.unix(timestamp).toString();
          console.log("Trait Created At :", traitCreatedAt.value);

          traitTokenId.value = token_id.toNumber();
          console.log("Trait TokenId :", traitTokenId.value);

          traitId.value = trait_id.toNumber();
          console.log("Trait Id :", traitId.value);

          /* Add new Trait to our Array for UI */
          attributes.value = attributes.value.concat({
            token_id: traitTokenId.value,
            trait_id: traitId.value,
            icon: traitIcon.value,
            display_type: traitDisplayType.value,
            trait_type: traitType.value,
            trait_value: traitValue.value,
            created_at: traitCreatedAt.value,
          });
          traitTokenId.value = null;
          traitId.value = null;
          traitIcon.value = "";
          traitDisplayType.value = "";
          traitType.value = "";
          traitValue.value = "";
          traitCreatedAt.value = "";
          store.setLoading(false);
        }
      );

      let tx = await contract.add_new_attribute(
        BigNumber.from(tokenId.value),
        traitIcon.value.toString(),
        traitDisplayType.value.toString(),
        traitType.value.toString(),
        traitValue.value.toString()
      );

      const stylesMining = ["color: black", "background: yellow"].join(";");
      console.log(
        "%c Adding new trait attribute... please wait!  %s",
        stylesMining,
        tx.hash
      );

      //wait until a block containing our transaction has been mined and confirmed.
      //new_attribute_added event has been emitted .
      const receipt = await tx.wait();

      const stylesReceipt = ["color: black", "background: #e9429b"].join(";");
      console.log(
        "%c🍵 We just added new attribute %s ",
        stylesReceipt,
        tx.hash
      );

      /* Check our Transaction results */
      if (receipt.status === 1) {
        /**
         * @dev NOTE: Switch up these links once we go to Production
         * Currently set to use Polygon Mumbai Testnet
         */
        const stylesPolygon = ["color: white", "background: #7e44df"].join(";");
        console.log(
          `%c🧬 NFT added new attribute, see transaction: https://mumbai.polygonscan.com/tx/${tx.hash} %s`,
          stylesPolygon,
          tx.hash
        );
        store.setLoading(false);
      }
      /* Stop loading */
      store.setLoading(false);
      return;
    } else {
      /* Stop loading */
      store.setLoading(false);
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    /* Stop loading */
    store.setLoading(false);
    console.log("error", error);
  }
};

/**
 * Show NFT Metatdata Trait to Edit
 * Traits start at 0 on mint, the date of mint is the first trait added
 */
const editTrait = (value) => {
  if (showTrait.value === value) {
    showTrait.value = 1;
  } else {
    showTrait.value = value;
  }
};

/**
 * Update trait icon of a Tableland NFT
 */
const updateTraitIcon = async (attribute) => {
  console.log("attribute", attribute);
  if (!attribute.token_id) {
    console.log(`Please enter a tokenId to continue!`);
    return;
  }
  /* This is the attribute number in attribute_table, an NFT can have many attributes */
  if (!attribute.trait_id) {
    console.log(`Please enter a trait id to continue!`);
    return;
  }
  if (!attribute.icon) {
    console.log(`Please enter a trait icon url to continue!`);
    return;
  }
  /* Start loading */
  store.setLoading(true);
  try {
    const { ethereum } = window;
    if (ethereum) {
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(
        contractAddress,
        contractAbi.abi,
        signer
      );
      /**
       *  Receive Emitted Event from Smart Contract
       *  @dev See traitDisplayTypeUpdated emitted from our smart contract update_display_type function
       */
      contract.on(
        "traitIconUpdated",
        (
          receiver,
          timestamp,
          attributes_table_id,
          icon,
          token_id,
          trait_id
        ) => {
          console.log("Receiver :", receiver);

          traitUpdatedAt.value = moment.unix(timestamp).toString();
          console.log("Trait Updated At :", traitUpdatedAt.value);

          traitTableId.value = attributes_table_id.toNumber();
          console.log("Trait Attributes Table Id :", traitTableId.value);

          traitIcon.value = icon.toString();
          console.log("Trait Icon Url :", traitIcon.value);

          traitTokenId.value = token_id.toNumber();
          console.log("Trait Token Id :", traitTokenId.value);

          traitId.value = trait_id.toNumber();
          console.log("Trait Id :", traitId.value);

          /* Update our traits Array */
          const attribute = attributes.value.find((object) => {
            return object.trait_id === traitId.value;
          });
          console.log(attribute);
          if (attribute !== undefined) {
            console.log("attribute.icon", attribute.icon);
            attribute.icon = traitIcon.value;
            console.log("attribute.icon", attribute.icon);
          }
          /* Stop loading */
          store.setLoading(false);
        }
      );

      let tx = await contract.update_icon(
        BigNumber.from(traitTokenId.value),
        BigNumber.from(traitId.value),
        traitIcon.value.toString()
      );

      const receipt = await tx.wait();
      const stylesReceipt = ["color: black", "background: #e9429b"].join(";");
      console.log(
        "%c🍵 We just updated a trait icon url %s ",
        stylesReceipt,
        tx.hash
      );

      /* Check our Transaction results */
      if (receipt.status === 1) {
        /**
         * @dev NOTE: Switch up these links once we go to Production
         * Currently set to use Polygon Mumbai Testnet
         */
        const stylesPolygon = ["color: white", "background: #7e44df"].join(";");
        console.log(
          `%c🧬 NFT updated a trait type, see transaction: https://mumbai.polygonscan.com/tx/${tx.hash} %s`,
          stylesPolygon,
          tx.hash
        );
        store.setLoading(false);
      }
      /* Stop loading */
      store.setLoading(false);
      return;
    } else {
      /* Stop loading */
      store.setLoading(false);
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    /* Stop loading */
    store.setLoading(false);
    console.log("error", error);
  }
};

/**
 * Update trait display type of a Tableland NFT
 */
const updateTraitDisplayType = async (attribute) => {
  console.log("attribute", attribute);

  if (!attribute.token_id) {
    console.log(`Please enter a tokenId to continue!`);
    return;
  }
  /* This is the attribute number in attribute_table, an NFT can have many attributes */
  if (!attribute.trait_id) {
    console.log(`Please enter a trait id to continue!`);
    return;
  }
  if (!attribute.display_type) {
    console.log(`Please enter a trait display type to continue!`);
    return;
  }
  /* Start loading */
  store.setLoading(true);
  try {
    const { ethereum } = window;
    if (ethereum) {
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(
        contractAddress,
        contractAbi.abi,
        signer
      );
      /**
       *  Receive Emitted Event from Smart Contract
       *  @dev See traitDisplayTypeUpdated emitted from our smart contract update_display_type function
       */
      contract.on(
        "traitDisplayTypeUpdated",
        (
          receiver,
          timestamp,
          attributes_table_id,
          display_type,
          token_id,
          trait_id
        ) => {
          console.log("Receiver :", receiver);

          traitUpdatedAt.value = moment.unix(timestamp).toString();
          console.log("Trait Created At :", traitUpdatedAt.value);

          traitTableId.value = attributes_table_id.toNumber();
          console.log("Trait Attributes Table Id :", traitTableId.value);

          traitDisplayType.value = display_type.toString();
          console.log("Trait Display Type :", traitDisplayType.value);

          traitTokenId.value = token_id.toNumber();
          console.log("Trait Token Id :", traitTokenId.value);

          traitId.value = trait_id.toNumber();
          console.log("Trait Id :", traitId.value);

          /* Update our traits Array */
          const attribute = attributes.value.find((object) => {
            return object.trait_id === traitId.value;
          });
          console.log(attribute);
          if (attribute !== undefined) {
            console.log("attribute.display_type", attribute.display_type);
            attribute.display_type = traitDisplayType.value;
            console.log("attribute.display_type", attribute.display_type);
          }
          /* Stop loading */
          store.setLoading(false);
        }
      );

      let tx = await contract.update_display_type(
        BigNumber.from(traitTokenId.value),
        BigNumber.from(traitId.value),
        traitDisplayType.value.toString()
      );

      const receipt = await tx.wait();
      const stylesReceipt = ["color: black", "background: #e9429b"].join(";");
      console.log(
        "%c🍵 just updated a trait display type %s ",
        stylesReceipt,
        tx.hash
      );

      /* Check our Transaction results */
      if (receipt.status === 1) {
        /**
         * @dev NOTE: Switch up these links once we go to Production
         * Currently set to use Polygon Mumbai Testnet
         */
        const stylesPolygon = ["color: white", "background: #7e44df"].join(";");
        console.log(
          `%c🧬 NFT updated a trait type, see transaction: https://mumbai.polygonscan.com/tx/${tx.hash} %s`,
          stylesPolygon,
          tx.hash
        );
        store.setLoading(false);
      }
      /* Stop loading */
      store.setLoading(false);
      return;
    } else {
      /* Stop loading */
      store.setLoading(false);
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    /* Stop loading */
    store.setLoading(false);
    console.log("error", error);
  }
};

/**
 * Update trait type of a Tableland NFT
 */
const updateTraitType = async (attribute) => {
  console.log("attribute", attribute);
  if (!attribute.token_id) {
    console.log(`Please enter a tokenId to continue!`);
    return;
  }
  /* This is the attribute number in attribute_table, an NFT can have many attributes */
  if (!attribute.trait_id) {
    console.log(`Error, no trait id found!`);
    return;
  }
  if (!attribute.trait_type) {
    console.log(`Please enter a trait type to continue!`);
    return;
  }
  /* Start loading */
  store.setLoading(true);
  try {
    const { ethereum } = window;
    if (ethereum) {
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(
        contractAddress,
        contractAbi.abi,
        signer
      );
      /**
       *  Receive Emitted Event from Smart Contract
       *  @dev See traitTypeUpdated emitted from our smart contract update_trait_type function
       */
      contract.on(
        "traitTypeUpdated",
        (
          receiver,
          timestamp,
          attributes_table_id,
          trait_type,
          token_id,
          trait_id
        ) => {
          console.log("Receiver :", receiver);

          traitUpdatedAt.value = moment.unix(timestamp).toString();
          console.log("Trait Created At :", traitUpdatedAt.value);

          traitTableId.value = attributes_table_id.toNumber();
          console.log("Trait Table Id :", traitTableId.value);

          traitType.value = trait_type.toString();
          console.log("Trait Type :", traitType.value);

          traitTokenId.value = token_id.toNumber();
          console.log("Trait TokenId :", traitTokenId.value);

          traitId.value = trait_id.toNumber();
          console.log("Trait Id :", traitId.value);

          /* Update our traits Array */
          const attribute = attributes.value.find((object) => {
            return object.trait_id === traitId.value;
          });
          console.log(attribute);
          if (attribute !== undefined) {
            console.log("attribute.trait_type", attribute.trait_type);
            attribute.trait_type = traitType.value;
            console.log("attribute.trait_type", attribute.trait_type);
          }
          /* Stop loading */
          store.setLoading(false);
        }
      );

      let tx = await contract.update_trait_type(
        BigNumber.from(traitTokenId.value),
        BigNumber.from(traitId.value),
        traitType.value.toString()
      );

      const receipt = await tx.wait();
      const stylesReceipt = ["color: black", "background: #e9429b"].join(";");
      console.log("%c🍵 just updated a trait type %s ", stylesReceipt, tx.hash);

      /* Check our Transaction results */
      if (receipt.status === 1) {
        /**
         * @dev NOTE: Switch up these links once we go to Production
         * Currently set to use Polygon Mumbai Testnet
         */
        const stylesPolygon = ["color: white", "background: #7e44df"].join(";");
        console.log(
          `%c🧬 NFT updated a trait type, see transaction: https://mumbai.polygonscan.com/tx/${tx.hash} %s`,
          stylesPolygon,
          tx.hash
        );
        store.setLoading(false);
      }
      /* Stop loading */
      store.setLoading(false);
      return;
    } else {
      /* Stop loading */
      store.setLoading(false);
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    /* Stop loading */
    store.setLoading(false);
    console.log("error", error);
  }
};

/**
 * Update trait value of a Tableland NFT
 */
const updateTraitValue = async (attribute) => {
  console.log("Attribute:", attribute);

  if (!attribute.token_id) {
    console.log(`Please enter a tokenId to continue!`);
    return;
  }
  /* This is the attribute number in attribute_table, an NFT can have many attributes */
  if (!attribute.trait_id) {
    console.log(`Please enter a trait id to continue!`);
    return;
  }
  if (!attribute.trait_value) {
    console.log(`Please enter a value for the trait to continue!`);
    return;
  }
  /* Start loading */
  store.setLoading(true);
  try {
    const { ethereum } = window;
    if (ethereum) {
      const provider = new ethers.providers.Web3Provider(ethereum);
      const signer = provider.getSigner();
      const contract = new ethers.Contract(
        contractAddress,
        contractAbi.abi,
        signer
      );

      /**
       *  Receive Emitted Event from Smart Contract
       *  @dev See valueUpdated emitted from our smart contract update_value function
       */
      contract.on(
        "valueUpdated",
        (
          receiver,
          timestamp,
          attributes_table_id,
          trait_value,
          token_id,
          trait_id
        ) => {
          console.log("Receiver :", receiver);

          traitUpdatedAt.value = moment.unix(timestamp).toString();
          console.log("Trait Updated At :", traitUpdatedAt.value);

          traitTableId.value = attributes_table_id.toNumber();
          console.log("Trait Table Id :", traitTableId.value);

          traitValue.value = trait_value.toString();
          console.log("Trait Value :", traitValue.value);

          traitTokenId.value = token_id.toNumber();
          console.log("Trait TokenId :", traitTokenId.value);

          traitId.value = trait_id.toNumber();
          console.log("Trait Id :", traitId.value);

          /* Update our traits Array */
          const attribute = attributes.value.find((object) => {
            return object.trait_id === traitId.value;
          });
          console.log(attribute);
          if (attribute !== undefined) {
            console.log("attribute.trait_value", attribute.trait_value);
            attribute.trait_value = traitValue.value;
            console.log("attribute.trait_value", attribute.trait_value);
          }
          /* Stop loading */
          store.setLoading(false);
        }
      );

      let tx = await contract.update_value(
        BigNumber.from(traitTokenId.value),
        BigNumber.from(traitId.value),
        traitValue.value.toString()
      );

      const receipt = await tx.wait();
      const stylesReceipt = ["color: black", "background: #e9429b"].join(";");
      console.log("%c🍵 just updated value %s ", stylesReceipt, tx.hash);

      /* Check our Transaction results */
      if (receipt.status === 1) {
        /**
         * @dev NOTE: Switch up these links once we go to Production
         * Currently set to use Polygon Mumbai Testnet
         */
        const stylesPolygon = ["color: white", "background: #7e44df"].join(";");
        console.log(
          `%c🧬 NFT updated value, see transaction: https://mumbai.polygonscan.com/tx/${tx.hash} %s`,
          stylesPolygon,
          tx.hash
        );
        store.setLoading(false);
      }
      /* Stop loading */
      store.setLoading(false);
      return;
    } else {
      /* Stop loading */
      store.setLoading(false);
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    /* Stop loading */
    store.setLoading(false);
    console.log("error", error);
  }
};

/**
 * Bridge NFT
 */
const bridgeNFT = async (token) => {
  /* Start bridging */
  store.setLoading(false);
  store.setBridging(true);
  /**
   * Bridge our NFT with custom deBridge DeNFT contracts
   */
  try {
    const { ethereum } = window;
    if (ethereum) {
      const chainIdFrom = bridgeFromOptions.value.find((chain) => {
        return chain.label === bridgeFrom.value;
      })?.value;

      const chainIdTo = bridgeToOptions.value.find((chain) => {
        return chain.label === bridgeTo.value;
      })?.value;

      await ethereum.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: BigNumber.from(chainIdFrom).toHexString() }],
      });

      const nftContractAddress = token.contract.address || token.contract; //contractAddressBridge.value;
      const tokenId = token.tokenId; //tokenIdBridge.value;
      const receipt = await bridge(
        nftContractAddress,
        tokenId,
        chainIdFrom,
        chainIdTo
      );

      /* Check our Transaction results */
      if (receipt.status === 1) {
        console.log("ok");
        const { txHash, chainIdFrom, chainIdTo } = getTxInfo();
        waitingClaim.value = true;
        timer.value = setInterval(async () => {
          const [signatureNum, requiredNum] = await getTxStatus(
            txHash,
            chainIdFrom,
            chainIdTo
          );
          console.log(signatureNum, requiredNum);
          if (!requiredNum) {
            claimStatusText.value = "Wating block confirmation...";
          } else {
            claimStatusText.value = `${signatureNum} / ${requiredNum}`;
            if (signatureNum >= requiredNum) {
              clearInterval(timer.value);
              claimStatusText.value = "";
              console.log("You can claim!!!");
            }
          }
        }, 1000);
      }

      /* Stop bridging */
      store.setBridging(false);
      return;
    } else {
      /* Stop bridging */
      store.setBridging(false);
      console.log("Ethereum object doesn't exist!");
    }
  } catch (error) {
    /* Stop bridging */
    store.setBridging(false);
    console.log("error", error);
  }
};

/**
 * Claim debridge Tx
 */
// eslint-disable-next-line no-unused-vars
const claimDebridgeTx = async () => {
  const { ethereum } = window;
  if (!ethereum) {
    throw Error();
  }

  const { txHash, chainIdFrom, chainIdTo } = getTxInfo();
  await ethereum.request({
    method: "wallet_switchEthereumChain",
    params: [{ chainId: BigNumber.from(chainIdTo).toHexString() }],
  });

  const receipt = await claim(txHash, chainIdFrom, chainIdTo);

  /* Check our Transaction results */
  if (receipt.status === 1) {
    console.log("ok");
    waitingClaim.value = false;
  }
};

/**
 * Update Bridge From Chain
 */
const updateBridgeFrom = (event) => {
  bridgeFrom.value = event.target.value;
};

/**
 * Update Bridge To Chain
 */
const updateBridgeTo = (event) => {
  bridgeTo.value = event.target.value;
};

/**
 * Approve Bridge Transfer
 */
const ConfirmApprovedBridge = (value) => {
  approvedBridge.value = value;
};

/**
 * Cancel Bridge Transfer
 */
const CancelBridge = () => {
  tokenIdBridge.value = "";
  contractAddressBridge.value = "";
  nameBridge.value = "";
  imageUrlBridge.value = null;
  approvedBridge.value = false;
  showBridgeTokens.value = true;
  /* Stop bridging */
  store.setBridging(false);
};

onMounted(async () => {
  /* Load our bg images */
  window.document.getElementById("bg-gradient").style.backgroundImage =
    "url('/brewtube.png')";
  window.document.getElementById("nft-modal").style.backgroundImage =
    "url('/brewingbubbles.svg')";

  /* Set scrollto func */
  window.scrollTo({
    top: 0,
    left: 0,
    behavior: "smooth",
  });
  /* First check our account */
  getAccount();
  await checkIfWalletIsConnected();
  await fetchTokens();

  /* Load some cool NFTs using NFT Port */
  if (trendingTokens.value.length === 0) {
    try {
      let trendingTokens = await store.contractNftSearch(
        "0x19b86299c21505cdf59cE63740B240A9C822b5E4",
        "ethereum",
        "metadata",
        "true",
        10,
        1
      );
      if (trendingTokens.nfts) {
        store.addTrendingTokens(...trendingTokens.nfts);
      }
    } catch (error) {
      console.log(error);
    }
  }

  const { txHash, chainIdFrom, chainIdTo } = getTxInfo();
  if (txHash) {
    waitingClaim.value = true;
    timer.value = setInterval(async () => {
      console.log("polling debridge tx status");
      console.log(txHash, chainIdFrom, chainIdTo);
      const [signatureNum, requiredNum] = await getTxStatus(
        txHash,
        chainIdFrom,
        chainIdTo
      );
      console.log(signatureNum, requiredNum);
      if (!requiredNum) {
        claimStatusText.value = "Wating block confirmation...";
      } else {
        claimStatusText.value = `${signatureNum} / ${requiredNum}`;
        if (signatureNum >= requiredNum) {
          clearInterval(timer.value);
          claimStatusText.value = "";
          console.log("You can claim!!!");
        }
      }
    }, 1000);
  }
});
onBeforeUnmount(() => {
  if (timer.value) {
    clearInterval(timer.value);
  }
});
</script>
<style lang="scss" scoped>
@import "../assets/styles/variables.scss";
@import "../assets/styles/mixins.scss";

section#mint {
  width: 100%;
  display: flex;
  flex-flow: row wrap;
  align-content: center;
  align-items: flex-start;
  justify-content: center;
  padding: 0;
  background: linear-gradient(
    269.69deg,
    #fbe2ff 0.3%,
    rgba(251, 226, 255, 0) 99.77%
  );
  @include breakpoint($break-sm) {
    flex-flow: column wrap;
  }
  @include breakpoint($break-xs) {
    flex-flow: column wrap;
  }
  article {
    width: 43%;
    min-height: 765px;
    flex-grow: 1 100%;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 0 5em 3em;
    @include breakpoint($break-xl) {
      padding: 0 1em 1em 1em;
    }
    @include breakpoint($break-lg) {
      padding: 0 1em 1em 1em;
    }
    @include breakpoint($break-md) {
      padding: 1em 0.5em;
    }
    @include breakpoint($break-sm) {
      width: 100%;
      padding: 0 0 2em 0;
    }
    @include breakpoint($break-xs) {
      width: 100%;
      padding: 0 0 2em 0;
    }
  }
  aside {
    width: 100%;
    flex: 1;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    margin: 0;
    padding: 0 auto;
    @include breakpoint($break-xl) {
      padding: 0 auto;
    }
    @include breakpoint($break-lg) {
      padding: 0 auto;
    }
    @include breakpoint($break-md) {
      padding: 2em 0 0 0;
      overflow: hidden;
    }
    @include breakpoint($break-sm) {
      width: 100%;
      padding: 0;
    }
    @include breakpoint($break-xs) {
      width: 100%;
      padding: 0;
    }
  }
}
section#content {
  height: inherit;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;

  .form-container {
    width: 428px;
    height: auto;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    align-content: center;
    background: #fff;
    border: 4px solid var(--gradient-100);
    box-shadow: 2px 2px 25px 6px rgba(43, 43, 43, 0.1);
    border-radius: 10px;
    margin: 0 auto 15px;
    padding: 30px 40px;
    z-index: 999;

    @include breakpoint($break-md) {
      width: 400px;
      margin: 0 auto 10px;
      padding: 25px 25px 20px;
    }
    @include breakpoint($break-sm) {
      width: 380px;
      margin: 0 auto 10px;
      padding: 20px 20px 20px;
    }
    @include breakpoint($break-xs) {
      width: 360px;
      margin: 0 auto 10px;
      padding: 20px 20px 20px;
    }

    .header-logo {
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      align-content: center;

      img,
      svg {
        width: 260px;
        margin: 20px auto 30px;
        object-fit: contain;
        overflow: hidden;
        @include breakpoint($break-md) {
          width: 200px;
          margin: 30px auto 10px;
        }
        @include breakpoint($break-sm) {
          width: 180px;
          margin: 30px auto 10px;
        }
      }
    }

    h1 {
      color: $mint-black;
      font-size: 2rem;
      line-height: 2rem;
      text-align: center;
      margin: 20px auto;
      span.emoji {
        font-size: 2.2rem;
      }
    }

    a {
      color: $mint-black;
      font-weight: bold;
      border-bottom: 1px solid $mint-black;
      text-decoration: none;
    }

    p {
      margin-bottom: 25px;
      text-align: center;
    }

    .mb-10 {
      margin-bottom: 10px;
    }
  }

  .form-container.home {
    height: auto;
  }

  .loading-message {
    width: 428px;
    height: auto;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    align-content: center;
    background: $mint-black;
    box-shadow: 2px 2px 25px 6px rgba(43, 43, 43, 0.1);
    border: 2px solid var(--gradient-100);
    box-shadow: 2px 2px 25px 6px rgba(43, 43, 43, 0.1);
    border-radius: 10px;
    border-radius: 10px;
    margin: 0 auto 20px;
    padding: 20px 40px;
    z-index: 999;
    .loading {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 100%;
      color: $white;
      font-size: 12px;
      line-height: 16px;
      font-weight: normal;
      text-align: center;
      transition: 0.4s;
    }
  }

  .input-row-first {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    width: 100%;
  }

  .input-row {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    margin-bottom: 12px;
    width: 100%;
  }

  .input-row-end {
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-end;
    width: 100%;
    .file-size {
      color: $mint-black;
      text-align: right;
      font-style: normal;
      font-weight: 400;
      font-size: 16px;
      line-height: 15px;
      margin: 15px 10px 5px 10px;
    }
  }

  .hidden {
    display: none;
  }

  label {
    color: $mint-blue;
    font-style: normal;
    font-weight: 800;
    font-size: 20px;
    line-height: 24px;
    letter-spacing: 0.1em;
    margin: 8px 0 2px 15px;
  }

  input[type="file"] {
    width: 100%;
    height: 40px;
    color: $mint-black;
    background-color: #fdfdfd;
    border: 1px solid #d9d9d9;
    border-radius: 30px;
    letter-spacing: 1px;
    font-size: 14px;
    line-height: 24px;
    margin-bottom: 12px;
    padding: 7px 6px 7px 15px;
    cursor: pointer;
  }

  input[type="file"]::placeholder {
    color: #a8a8a8;
    letter-spacing: 1px;
  }
  ::-webkit-file-upload-button {
    background: $mint-green;
    border: none;
    border-radius: 30px;
    color: $mint-blue;
    padding: 0px 10px;
    font-style: normal;
    font-weight: 800;
    font-size: 14px;
    line-height: 24px;
    text-align: center;
    float: right;
    cursor: pointer;
  }

  input {
    width: 100%;
    height: 40px;
    color: $mint-black;
    background-color: #fdfdfd;
    border: 1px solid #d9d9d9;
    border-radius: 30px;
    letter-spacing: 1px;
    font-size: 14px;
    line-height: 24px;
    margin-bottom: 5px;
    padding: 7px;
    text-align: left;
  }

  input::placeholder {
    color: #a8a8a8;
    letter-spacing: 1px;
  }

  input:read-only {
    color: #1a1a1a;
    border: 1px dashed #e0e0e0;
    letter-spacing: 1px;
    cursor: not-allowed;
  }

  input:focus {
    border: 1px solid $mint-green;
    outline: none;
  }

  textarea {
    width: 100%;
    color: $mint-black;
    background-color: #fdfdfd;
    border: 1px solid #d9d9d9;
    border-radius: 30px;
    letter-spacing: 1px;
    font-size: 14px;
    line-height: 24px;
    margin-bottom: 5px;
    padding: 10px;
    text-align: left;
    resize: none;
  }

  textarea::placeholder {
    color: #a8a8a8;
    letter-spacing: 1px;
  }

  textarea:focus {
    border: 1px solid $mint-green;
    outline: none;
  }

  .select-row {
    width: 100%;
    position: relative;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    margin-bottom: 15px;
    label.black {
      width: 100%;
      color: $mint-black;
      font-style: normal;
      font-weight: 800;
      font-size: 20px;
      line-height: 24px;
      letter-spacing: 0.1em;
      margin: 8px 0 2px 15px;
      text-align: left;
    }
  }
  select.bridge-from-chain {
    width: 100%;
    color: $mint-blue;
    background-color: #ffffff;
    border: 1px solid $mint-blue;
    border-radius: 30px;
    letter-spacing: 1px;
    font-size: 13px;
    padding: 11px 10px 9px;
    margin: 0 5px;
    text-align: center;

    @include breakpoint($break-sm) {
      width: 98%;
      margin: 0 1%;
    }
    @include breakpoint($break-xs) {
      width: 98%;
      margin: 0 1%;
    }
  }
  select.bridge-from-chain::placeholder {
    color: $mint-blue;
    letter-spacing: 1px;
  }
  select.bridge-from-chain:focus {
    border: 1px solid $mint-black;
    outline: none;
  }
  select.bridge-from-chain:disabled {
    background: #c6c6c6;
    color: #101010;
    cursor: not-allowed;
  }

  .bridge-step-one {
    width: 100%;
    color: $mint-black;
    font-style: normal;
    font-weight: 300;
    font-size: 12px;
    line-height: 14px;
    margin: 8px 0 2px 15px;
    text-align: left;
  }

  select.bridge-to-chain {
    width: 100%;
    color: $mint-blue;
    background-color: #ffffff;
    border: 1px solid $mint-blue;
    border-radius: 30px;
    letter-spacing: 1px;
    font-size: 13px;
    padding: 11px 10px 9px;
    margin: 0 5px;
    text-align: center;

    @include breakpoint($break-sm) {
      width: 98%;
      margin: 0 1%;
      border-top-left-radius: 5px;
      border-top-right-radius: 5px;
      border-bottom-left-radius: 0;
    }
    @include breakpoint($break-xs) {
      width: 98%;
      margin: 0 1%;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
  }
  select.bridge-to-chain::placeholder {
    color: $mint-blue;
    letter-spacing: 1px;
  }
  select.bridge-to-chain:focus {
    border: 1px solid $mint-black;
    outline: none;
  }
  select.bridge-to-chain:disabled {
    background: #c6c6c6;
    color: #101010;
    cursor: not-allowed;
  }

  .button-container {
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
  }
  .mint-button {
    color: $mint-black;
    background-color: $mint-green;
    font-size: 18px;
    font-weight: bold;
    width: 48%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 1% 10px 0;
    transition: 0.4s;
    cursor: pointer;
    &:hover {
      color: $mint-blue;
    }
  }
  .mint-button:disabled {
    color: $white;
    background-color: $mint-black;
    cursor: not-allowed;
  }

  .mint-done-button {
    color: $mint-black;
    background-color: $mint-green;
    font-size: 18px;
    font-weight: bold;
    width: 48%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 1% 10px 0;
    transition: 0.4s;
    cursor: pointer;
    &:hover {
      color: $mint-blue;
    }
  }

  .connect-button {
    color: $white;
    background-color: $mint-black;
    font-size: 18px;
    font-weight: bold;
    width: 48%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 1% 10px 0;
    transition: 0.4s;
    cursor: pointer;
    &:hover {
      color: $mint-blue;
    }
  }

  .explore-button {
    color: $white;
    background-color: $mint-blue;
    font-size: 18px;
    font-weight: bold;
    width: 48%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 1% 10px 0;
    transition: 0.4s;
    cursor: pointer;
    a {
      color: $white;
      text-decoration: none;
      border-bottom: none;

      &:hover {
        color: $black;
      }
    }
  }
  .bridge-button-left {
    color: $white;
    background-color: $mint-blue;
    font-size: 18px;
    font-weight: bold;
    width: 48%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 1% 10px 0;
    transition: 0.4s;
    cursor: pointer;
    &:hover {
      color: $mint-black;
    }
  }
  .bridge-button-left:disabled {
    background: #c6c6c6;
    color: #101010;
    cursor: not-allowed;
  }
  .bridge-button-right {
    color: $white;
    background-color: $mint-blue;
    font-size: 18px;
    font-weight: bold;
    width: 48%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 0 10px 1%;
    transition: 0.4s;
    cursor: pointer;
    &:hover {
      color: $mint-black;
    }
  }

  .claim-button {
    color: $white;
    background-color: $mint-blue;
    font-size: 18px;
    font-weight: bold;
    width: 100%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 1% 10px 0;
    transition: 0.4s;
    cursor: pointer;
    &:hover {
      color: $mint-black;
    }
  }
  .claim-button:disabled {
    background: #c6c6c6;
    color: #101010;
    cursor: not-allowed;
  }
  .back-button {
    color: $white;
    background-color: $mint-black;
    font-size: 18px;
    font-weight: bold;
    width: 48%;
    height: 55px;
    border: 0;
    border-radius: 30px;
    margin: 10px 0 10px 1%;
    transition: 0.4s;
    cursor: pointer;
    &:hover {
      color: $mint-blue;
    }
  }
}

.bubbles-brewing {
  // background-image: url("./brewingbubbles.png");
  background-position: center center;
  background-repeat: no-repeat;
  background-size: 700px;
  @include breakpoint($break-md) {
    background-position: center center;
    background-repeat: no-repeat;
    background-size: 100%;
  }
  @include breakpoint($break-sm) {
    background-position: center top;
    background-repeat: no-repeat;
    background-size: 600px;
  }
  @include breakpoint($break-xs) {
    background-position: center top;
    background-repeat: no-repeat;
    background-size: 100%;
  }
}

section#nft-modal {
  min-height: 720px;
  color: $mint-black;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-content: flex-start;
  align-items: center;

  padding: 0;

  @include breakpoint($break-md) {
    padding: 20px 0;
  }
  @include breakpoint($break-sm) {
    padding: 20px 0;
  }
  @include breakpoint($break-xs) {
    padding: 20px 0;
  }

  .nft-modal-loading {
    width: 600px;
    height: 100%;
    min-height: 720px;
    display: flex;
    flex-direction: column;
    align-content: center;
    justify-content: center;
    align-items: center;
    padding: 0;
    @include breakpoint($break-xl) {
      width: 100%;
      padding: 0 auto;
    }
    @include breakpoint($break-lg) {
      width: 100%;
      padding: 0;
    }
    @include breakpoint($break-md) {
      width: 100%;
      padding: 0 auto;
    }
    @include breakpoint($break-sm) {
      width: 100%;
      padding: 0;
    }
    @include breakpoint($break-xs) {
      width: 100%;
      padding: 0;
    }
  }

  .nft-modal-card {
    width: 500px;
    display: flex;
    flex-direction: column;
    align-content: center;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    background: #f4f4f4;
    border: 4px solid var(--gradient-100);
    box-shadow: 2px 2px 25px 6px rgba(43, 43, 43, 0.1);
    border-radius: 10px;
    padding: 20px 20px 20px 20px;
    margin-bottom: 20px;
    @include breakpoint($break-lg) {
      width: 89%;
      padding: 20px 20px 10px 20px;
    }
    @include breakpoint($break-md) {
      width: 81%;
      padding: 20px 20px 10px 20px;
    }
    @include breakpoint($break-sm) {
      width: 81%;
      padding: 20px 20px 10px 20px;
    }
    @include breakpoint($break-xs) {
      width: 100%;
      padding: 20px 20px 10px 20px;
    }
  }

  .nft-modal-video {
    width: 100%;
    margin: 0 auto;
    padding: 0;
    overflow: hidden;
    background: #f4f4f4;
  }
  .nft-modal-image {
    width: 100%;
    margin: 0 auto;
    padding: 0;
    overflow: hidden;

    img,
    svg {
      width: 100%;
      height: 100%;
      object-fit: contain;
      overflow: hidden;
    }
  }

  .nft-modal-title {
    width: 100%;
    color: $mint-black;
    font-size: 1.7rem;
    font-weight: 400;
    text-align: center;
    margin: 10px auto 0;
  }

  .nft-modal-description {
    color: $mint-black;
    width: 100%;
    font-size: 16px;
    font-weight: normal;
    text-align: center;
    margin: 10px auto 0;
  }
  .nft-modal-external-url {
    color: #1a1a1a;
    width: 100%;
    font-size: 14px;
    font-weight: normal;
    text-align: center;
    margin: 10px auto 0;
  }

  .nft-modal-edit-attributes {
    color: #1a1a1a;
    width: 100%;
    font-size: 14px;
    font-weight: normal;
    text-align: center;
    margin: 10px auto 0;
    .nft-attribute-cards {
      display: flex;
      flex-direction: row wrap;
      align-content: flex-start;
      justify-content: space-between;
      align-items: flex-start;
      .nft-attribute-card {
        width: 86%;
        color: $mint-black;
        background-color: #fff;
        border: 1px solid $mint-blue;
        border-radius: 10px;
        letter-spacing: 1px;
        font-size: 12px;
        line-height: 20px;
        margin: 0 auto 5px;
        padding: 10px;
        text-align: left;
        .nft-attribute-card-trait {
          display: flex;
          flex-direction: row wrap;
          align-content: flex-start;
          justify-content: space-between;
          align-items: flex-start;
          .edit-button {
            color: $mint-blue;
            background-color: $white;
            font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans",
              "Droid Sans", "Helvetica Neue", sans-serif;
            font-style: normal;
            font-weight: 800;
            font-size: 11px;
            line-height: 14px;
            text-align: right;
            width: 30px;
            padding: 4px 5px;
            height: auto;
            border: 0;
            margin: 0 0 0 5px;
            transition: 0.4s;
            cursor: pointer;
            &:hover {
              color: $mint-black;
            }
          }
        }
      }
    }

    .nft-attribute {
      width: 86%;
      margin: 0 auto;
      background: $white;
      border: 1px solid $mint-black;
      border-radius: 10px;
      padding: 5px;
      input {
        width: 100%;
        height: 30px;
        color: $mint-black;
        background-color: #fff;
        border-top: 1px solid $white;
        border-left: 1px solid $white;
        border-right: 1px solid $white;
        border-bottom: 1px solid $mint-black;
        letter-spacing: 1px;
        font-size: 12px;
        line-height: 20px;
        margin-bottom: 5px;
        padding: 7px;
        text-align: center;
      }
      input::placeholder {
        color: #a8a8a8;
        letter-spacing: 1px;
      }
      input:focus {
        border: 1px dashed $mint-blue;
        outline: none;
      }
    }
  }
  .nft-modal-add-attributes {
    color: #1a1a1a;
    width: 100%;
    font-size: 14px;
    font-weight: normal;
    text-align: center;
    margin: 10px auto 0;
    input {
      width: 86%;
      height: 30px;
      color: $mint-black;
      background-color: #fdfdfd;
      border: 1px solid #d9d9d9;
      border-radius: 30px;
      letter-spacing: 1px;
      font-size: 12px;
      line-height: 20px;
      margin-bottom: 5px;
      padding: 7px;
      text-align: center;
    }

    input::placeholder {
      color: #a8a8a8;
      letter-spacing: 1px;
    }

    input:read-only {
      color: #1a1a1a;
      border: 1px dashed #e0e0e0;
      letter-spacing: 1px;
      cursor: not-allowed;
    }

    input:focus {
      border: 1px dashed $mint-blue;
      outline: none;
    }
  }

  .nft-modal-approve {
    width: 100%;
    display: flex;
    flex-direction: row;
    align-content: center;
    justify-content: center;
    align-items: center;
    margin-top: 5px;

    .add-button {
      color: $white;
      background-color: $mint-blue;
      font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans",
        "Helvetica Neue", sans-serif;
      font-style: normal;
      font-weight: 800;
      font-size: 14px;
      line-height: 24px;
      text-align: center;
      width: 200px;
      border-radius: 30px;
      padding: 4px;
      height: auto;
      border: 0;
      margin: 0 5px 0 0;
      transition: 0.4s;
      cursor: pointer;
      &:hover {
        color: $mint-black;
      }
    }
    .approve-button {
      color: $white;
      background-color: $mint-blue;
      font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans",
        "Helvetica Neue", sans-serif;
      font-style: normal;
      font-weight: 800;
      font-size: 14px;
      line-height: 24px;
      text-align: center;
      width: 100px;
      border-radius: 30px;
      padding: 4px 12px 5px;
      height: auto;
      border: 0;
      margin: 0 5px 0 5px;
      transition: 0.4s;
      cursor: pointer;
      &:hover {
        color: $mint-black;
      }
    }
    .approved-button {
      color: $black;
      background-color: $mint-green;
      font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans",
        "Helvetica Neue", sans-serif;
      font-style: normal;
      font-weight: 800;
      font-size: 14px;
      line-height: 24px;
      text-align: center;
      width: 100px;
      border-radius: 30px;
      padding: 4px 12px 5px;
      height: auto;
      border: 0;
      margin: 0 5px 0 5px;
      transition: 0.4s;
      cursor: not-allowed;
      &:hover {
        color: $mint-black;
      }
    }
    .file-image-link {
      background: $mint-black;
      border: none;
      border-radius: 30px;
      padding: 4px 12px 5px;
      margin: 0;
      cursor: pointer;
      a {
        color: $white;
        font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans",
          "Droid Sans", "Helvetica Neue", sans-serif;
        font-style: normal;
        font-weight: 800;
        font-size: 14px;
        line-height: 24px;
        text-align: center;
        transition: 0.4s;
        &:hover {
          color: $mint-blue;
        }
      }
    }
    .file-table-link {
      background: $mint-black;
      border: none;
      border-radius: 30px;
      padding: 4px 12px 5px;
      margin: 0;
      cursor: pointer;
      a {
        color: $white;
        font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans",
          "Droid Sans", "Helvetica Neue", sans-serif;
        font-style: normal;
        font-weight: 800;
        font-size: 14px;
        line-height: 24px;
        text-align: center;
        transition: 0.4s;
        &:hover {
          color: $mint-blue;
        }
      }
    }
    .cancel-button {
      color: $white;
      background-color: $mint-orange;
      font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans",
        "Helvetica Neue", sans-serif;
      font-style: normal;
      font-weight: 800;
      font-size: 14px;
      line-height: 24px;
      text-align: center;
      width: 100px;
      border-radius: 30px;
      padding: 4px 12px 5px;
      height: auto;
      border: 0;
      margin: 0 0 0 5px;
      transition: 0.4s;
      cursor: pointer;
      &:hover {
        color: $mint-black;
      }
    }
  }
}
.nft-bridge-tokens {
  width: 92%;
  height: 700px;
  color: $mint-black;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-content: center;
  align-items: center;
  box-sizing: border-box;
  background: #f4f4f4;
  border: 4px solid var(--gradient-100);
  box-shadow: 2px 2px 25px 6px rgba(43, 43, 43, 0.1);
  border-radius: 10px;
  padding: 0 20px 10px 20px;
  overflow: scroll;

  @include breakpoint($break-lg) {
    padding: 0 0 3em 1em;
  }
  @include breakpoint($break-md) {
    padding: 0 0 3em 0;
  }
  @include breakpoint($break-sm) {
    padding: 0 0 3em 0;
  }
  @include breakpoint($break-xs) {
    padding: 0 0 3em 0;
  }

  .row-header {
    width: 100%;
    max-width: 1280px;
    display: flex;
    flex-direction: row;
    align-content: flex-start;
    justify-content: center;
    align-items: center;
    margin: 25px 0;
    @include breakpoint($break-lg) {
      width: 100%;
      margin: 0 auto;
    }
    @include breakpoint($break-md) {
      width: 100%;
      margin: 0 auto;
    }
    @include breakpoint($break-sm) {
      width: 85%;
      margin: 0 auto;
    }
    @include breakpoint($break-xs) {
      width: 85%;
      margin: 0 auto;
    }
    h2 {
      width: 100%;
      color: $mint-black;
      font-style: normal;
      font-weight: 700;
      font-size: 28px;
      line-height: 42px;
      text-align: left;
      margin: 0 0 20px 20px;
      .arrow-down {
        margin: 10px 0 -10px 10px;
      }
    }
  }

  .row {
    width: 100%;
    display: flex;
    flex-direction: column;
    align-content: center;
    justify-content: center;
    align-items: center;
    padding: 0;
  }

  .token-list {
    width: 100%;
    max-width: 1280px;
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
    align-content: center;
    justify-content: center;
    align-items: flex-start;
    @include breakpoint($break-lg) {
      width: 100%;
      margin: 0 auto;
      grid-template-columns: repeat(2, 1fr);
    }
    @include breakpoint($break-md) {
      width: 100%;
      margin: 0 auto;
      grid-template-columns: repeat(1, 1fr);
    }
    @include breakpoint($break-sm) {
      width: 100%;
      margin: 0 auto;
      grid-template-columns: repeat(2, 1fr);
    }
    @include breakpoint($break-xs) {
      width: 100%;
      margin: 0 auto;
      grid-template-columns: repeat(1, 1fr);
    }
  }
}

.nft-bridge-modal-card {
  width: 500px;
  display: flex;
  flex-direction: column;
  align-content: center;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  background: #f4f4f4;
  border: 4px solid var(--gradient-100);
  box-shadow: 2px 2px 25px 6px rgba(43, 43, 43, 0.1);
  border-radius: 10px;
  padding: 20px;
  @include breakpoint($break-lg) {
    width: 89%;
  }
  @include breakpoint($break-md) {
    width: 81%;
  }
  @include breakpoint($break-sm) {
    width: 81%;
  }
  @include breakpoint($break-xs) {
    width: 100%;
  }

  .nft-bridge-modal-video {
    width: 100%;
    margin: 0 auto;
    padding: 0;
    overflow: hidden;
    background: #f4f4f4;
  }
  .nft-bridge-modal-image {
    width: 100%;
    margin: 0 auto;
    padding: 0;
    overflow: hidden;

    img,
    svg {
      width: 100%;
      max-width: 560px;
      height: 100%;
      object-fit: contain;
      overflow: hidden;
    }
  }

  .nft-bridge-modal-title {
    width: 100%;
    color: $mint-black;
    font-size: 1.4rem;
    font-weight: 400;
    text-align: center;
    margin: 10px auto 0;
  }

  .nft-bridge-modal-tokenId {
    color: $mint-black;
    width: 100%;
    font-size: 16px;
    font-weight: normal;
    text-align: center;
    margin: 10px auto 0;
  }
  .nft-bridge-modal-contract-address {
    color: #1a1a1a;
    width: 100%;
    font-size: 14px;
    font-weight: normal;
    text-align: center;
    margin: 10px auto 5px;
  }
  .nft-bridge-modal-approve {
    width: 50%;
    display: flex;
    flex-direction: row;
    align-content: center;
    justify-content: center;
    align-items: center;
    .approve-button {
      color: $white;
      background-color: $mint-blue;
      font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans",
        "Helvetica Neue", sans-serif;
      font-style: normal;
      font-weight: 800;
      font-size: 14px;
      line-height: 24px;
      text-align: center;
      width: 100px;
      border-radius: 30px;
      padding: 4px 12px 5px;
      height: auto;
      border: 0;
      margin: 0 5px;
      transition: 0.4s;
      cursor: pointer;
      &:hover {
        color: $mint-black;
      }
    }
    .approved-button {
      color: $black;
      background-color: $mint-green;
      font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans",
        "Helvetica Neue", sans-serif;
      font-style: normal;
      font-weight: 800;
      font-size: 14px;
      line-height: 24px;
      text-align: center;
      width: 100px;
      border-radius: 30px;
      padding: 4px 12px 5px;
      height: auto;
      border: 0;
      margin: 0 0 0 5px;
      transition: 0.4s;
      cursor: not-allowed;
      &:hover {
        color: $mint-black;
      }
    }
    .cancel-button {
      color: $white;
      background-color: $mint-orange;
      font-family: Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans",
        "Helvetica Neue", sans-serif;
      font-style: normal;
      font-weight: 800;
      font-size: 14px;
      line-height: 24px;
      text-align: center;
      width: 100px;
      border-radius: 30px;
      padding: 4px 12px 5px;
      height: auto;
      border: 0;
      margin: 0 0 0 5px;
      transition: 0.4s;
      cursor: pointer;
      &:hover {
        color: $mint-black;
      }
    }
  }
}

section#collections {
  width: 100%;
  color: $mint-black;
  background: $mint-blue;
  display: flex;
  flex-direction: column;
  align-content: center;
  align-items: center;
  justify-content: center;
  padding: 3em 0;

  .row-header {
    width: 100%;
    max-width: 1280px;
    display: flex;
    flex-direction: row;
    align-content: flex-start;
    justify-content: center;
    align-items: center;
    margin: 25px 0;
    @include breakpoint($break-lg) {
      width: 80%;
      margin: 0 auto;
    }
    @include breakpoint($break-md) {
      width: 83%;
      margin: 0 auto;
    }
    @include breakpoint($break-sm) {
      width: 85%;
      margin: 0 auto;
    }
    @include breakpoint($break-xs) {
      width: 85%;
      margin: 0 auto;
    }
    h2 {
      width: 100%;
      color: $white;
      font-style: normal;
      font-weight: 700;
      font-size: 36px;
      line-height: 42px;
      text-align: left;
      margin: 0 0 20px 20px;
      .mint-black {
        color: $mint-black;
      }
      .arrow-down {
        margin: 10px 0 -10px 10px;
      }
    }
  }
  .row {
    display: flex;
    flex-direction: row;
    align-content: center;
    justify-content: center;
    align-items: center;
    padding: 0;
  }

  .token-list {
    width: 100%;
    max-width: 1280px;
    display: inline-block;
    margin: 0 auto;
    @include breakpoint($break-lg) {
      width: 80%;
      margin: 0 auto;
    }
    @include breakpoint($break-md) {
      width: 86%;
      margin: 0 auto;
    }
    @include breakpoint($break-sm) {
      width: 97%;
      margin: 0 auto;
    }
    @include breakpoint($break-xs) {
      width: 80%;
      margin: 0 auto;
    }
  }
}
</style>
